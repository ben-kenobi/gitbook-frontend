# JS知识测验

### 选择题（多选）

1. 下面哪些是属于JS语言动态性的特征：
   1. 函数参数的个数在运行时确定。
   2. 运行时将一段字符串转换成JS脚本。
   3. 函数也是对象
   4. 基于原型来构造对象
2. 关于JS与ES的关系下面说法正确的是
   1. JS最初是基于ES进行设计的
   2. ES是JS的行业标准
   3. 所有JS解释器都基于最新的ES标准设计
   4. ES中定义了所有JS的接口与行为
3. 关于JS中变量声明，说法正确的是
   1. let用来声明常量
   2. 一般使用var来声明局部变量
   3. const用来声明局部常量
   4. let用来声明局部变量
4. \(超纲\) JS中逻辑运算符 == 与 === 的区别是
   1. == 比较等式两边类型是否相等
   2. === 比较等式两边类型是否相等
   3. === 会将等式两边变量转换成相同类型后再比较值
   4. == 会将等式两边变量转换成相同类型后再比较值
5. 关于JS的类型系统相关描述正确的是
   1. JS类型系统定义了8种基本类型
   2. JS中数据类型除了8种基本类型，还有多种包装类型
   3. 对包装类型Number使用`typeof`运算符将得到'number'
   4. 对包装类型Function使用`typeof`运算符将得到'object'
6. 关于构造函数与普通函数的区别，下列说法正确的是
   1. 构造函数可以创建并返回对象，普通函数不行。
   2. `new 构造函数`与`调用普通函数`创建出来的对象是一样的。
   3. 构造函数与普通函数在形式上没有区别，只是使用场景不一样。
   4. 可以对构造函数使用`new` 操作符，普通函数不行。
7. 关于函数中`this`的说法正确的是
   1. 函数中this始终指向调用该函数的对象
   2. bind函数中的this始终指向绑定的对象
   3. call方式调用函数后，该函数的this始终指向call指定的对象
   4. 箭头函数的this指向是固定不变的
8. 关于`prototype chain`说法正确的是
   1. `prototype chain`指函数中 **prototype** 属性组成的对象属性查找链条。
   2. `prototype chain` 指对象中 `__proto__`属性组成的对象属性查找链条。
   3. `prototype chain` 查找对象属性会一直查找到顶层原型才停止。
   4. `prototype chain` 查找对象属性会从顶层原型开始查找，直到找到为止。

### 思考题

1. 思考java或OC中方法的this与JS中方法的this有何异同点，造成这种不同的原因是什么？
2. 思考下JS中的继承与java或OC中的继承实现的效果上有何不同的地方？（从JS是基于原型对象的继承链角度思考）
3. 思考JS的动态性，在平时开发中有哪些正面作用，并会带来哪些负面作用。

### 实操题

1. \(必须完成\) 画出使用RN开发的APP 中 JS脚本，JS引擎和宿主环境具体是什么，和互相之间的关系。
2. \(必须完成\) 使用class方式实现一个继承关系，然后再使用函数prototype属性的方式，再实现一遍这个继承关系。
3. \(可选完成）JS内置的包装函数 `Date`，通过`new Date()`的方式会得到一个日期对象，通过`Date()`的方式会得到一个日期的字符串。尝试自己实现一个`MyDate`函数，实现同样的效果。

## 答案

### 选择题

1. AB。 其他两个与JS的动态性无关。
2. B。 ES最初是基于JS进行制定的。JS解释器（即JS引擎）并没有都实现了ES最新标准。ES中只是定义了JS的语法标准与实现规范，并不涉及特定宿主相关的JS接口。
3. CD。 let声明的是局部变量。开发中局部变量一般都使用let，var基本不用。
4. D。== 会将等式两边变量类型转换成一致后再比较，=== 是直接比较两端类型和值是否都相等。有兴趣可以搜索 `js == VS ===` 和 `js type coercion` 了解JS中隐式类型转换的场景。
5. A。 JS包装类型只是一个函数对象，属于object这个基本类型。对 包装类型做 typeof运算得到的都是'function'。
6. C。 构造函数与普通函数都可以返回对象。构造函数与普通函数也都可以使用new 操作符。使用构造函数与普通函数两个叫法只是为了区分函数的使用场景。`new 构造函数`创建出来的对象是基于构造函数的**prototype**属性为原型创建的，普通函数创建的对象则不是
7. BD。bind函数，箭头函数中的this则不是指向调用他们的对象。call调用的函数中的this，仅在执行call的那次调用时，this指向call指定的对象。
8. B。`prototype chain`查找属性 会在找到指定属性，或到达\_\_proto\_\_为null时停止。`prototype chain`查找属性是从对象本身开始查找，再往对象的原型，对象原型的原型上去查找。

### 思考题（参考答案）

**1、**

**相同点：**JS中函数的this与java或OC中的方法的this一般情况下都是指向调用该函数的对象。

 **不同点：**

1. JS中的函数可以绑定固定的this或手动指定this，而java或OC中一般不能这么做。
2. JS中同一函数中this可以指向任意对象，而java或OC中一般只会指向声明该函数的类或其子类的实例对象。

造成JS函数中this指向不清晰的原因是JS中函数也是一个对象，可以在运行时被赋值给任意JS对象，因此JS函数被调用时，调用该函数的对象可能是任意对象。Java或OC中方法声明后，一般不可以\(不使用运行时API情况下）在运行时赋值给其他对象。



**2、**

Java或OC中的类型和实例是两套系统，类型定义了实例的模版和方法，继承是类型系统上的继承，实例是按照类型的模版构建，先按照父类模版构建，再按照子类模版构建，这里涉及到父类，子类，子类实例三个对象。

 JS的继承是通过原型链的方式实现的，类型与实例没有显著界限，只是在使用场景上做区分。JS的对象构建是初始化一个对象A，并将对象的\_\_proto\_\_属性设置为另一个对象B，则可以理解为A继承自B，而A本身也可以作为其他对象的原型，因此JS的继承可以理解为是实例对实例的继承。

可以说Java或OC的继承只是子类型继承了父类型的模版和方法，而JS中的继承是子对象继承了父对象本身，拥有父对象所有的属性、方法、和值,且JS对象的原型可以随时被修改，从语意上就是JS中的继承关系在运行时可以被改变。



**3、**

JS的动态特性可以为开发带来很多灵活的功能，比如运行时修改对象属性，运行时生成JS脚本来执行等，这些可以帮助开发人员很容易实现一些复杂的特性。但是动态性也带来了很多问题，动态性有以下几个公认的问题：

1. 降低了代码的正确性
2. 降低了代码的安全性
3. 降低了代码的可预测性
4. 降低了代码的执行效率

以上这些问题在JS项目开始变的庞大后，协同开发人员变多后，将变的比较明显。特别是前三项缺点，将导致项目代码不够健壮，且在多人协同开发中导致维护人员很难理解他人代码的意图。这就是入TS要解决的问题。

